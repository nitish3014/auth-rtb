name: CI/CD Deploy to EKS

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      AWS_REGION:          us-east-1
      AWS_ACCOUNT_ID:      972251037797
      EKS_CLUSTER_NAME:    rtb-eks-dev
      DEPLOYMENT_NAME:     rtb-dev-auth-service
      K8S_NAMESPACE:       default
      BASTION_IP:          35.170.113.92
      BASTION_USER:        ubuntu
      S3_BUCKET_NAME:      rtb-dev-artifact
      S3_ARTIFACT_KEY:     rtb-core-0.0.1-SNAPSHOT.jar

    steps:
      # 1. Checkout
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 1

      # 2. Fix gradlew permissions
      - name: Set gradlew executable
        run: chmod +x gradlew

      # 3. Notify Build Start
      - name: Notify Build Start
        continue-on-error: true
        run: |
          commit_details=$(git log -1 --pretty=format:'%s|%an' || echo "Unknown|Unknown")
          commit_message=${commit_details%%|*}
          committer_name=${commit_details##*|}
          
          payload='{
            "text": "üöÄ *Build Started*\n*Repository:* '"$GITHUB_REPOSITORY"'\n*Run #:* '"$GITHUB_RUN_NUMBER"'\n*Commit:* '"$commit_message"'\n*By:* '"$committer_name"'\n*URL:* '"$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"'"
          }'
          
          curl -X POST -H "Content-Type: application/json" \
            --data "$payload" \
            "${{ secrets.GOOGLE_CHAT_WEBHOOK }}" || echo "Notification failed"

      # 4. Configure AWS creds
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # 5. Fetch PEM keys
      - name: Fetch public/private keys
        run: |
          echo "${{ secrets.PUBLIC_KEY_FILE }}" > public_key.pem
          echo "${{ secrets.PRIVATE_KEY_FILE }}" > private_key.pem
          chmod 600 public_key.pem private_key.pem

      # 6. Capture commit details
      - name: Capture commit details
        run: |
          INFO=$(git log -1 --pretty=format:'%s|%an')
          echo "COMMIT_MESSAGE=${INFO%%|*}" >> $GITHUB_ENV
          echo "COMMIT_AUTHOR=${INFO##*|}" >> $GITHUB_ENV

      # 7. Fetch artifact from S3
      - name: Fetch JAR from S3
        run: |
          mkdir -p libs
          aws s3 cp s3://${{ env.S3_BUCKET_NAME }}/${{ env.S3_ARTIFACT_KEY }} libs/ || exit 1

      # 8. Retrieve Git version
      - name: Retrieve Git version
        run: |
          SHA=$(git rev-parse --short HEAD)
          VER="${SHA}-${GITHUB_RUN_NUMBER}"
          echo "VERSION=${VER}" >> $GITHUB_ENV

      # 9. Install jq
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      # 10. Install kubectl
      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # 11. Fetch kubeconfig via Bastion
      - name: Fetch kubeconfig via Bastion
        run: |
          echo "${{ secrets.BASTION_PEM_KEY }}" > bastion_key.pem
          chmod 600 bastion_key.pem
          ssh -o StrictHostKeyChecking=no \
              -i bastion_key.pem \
              ${{ env.BASTION_USER }}@${{ env.BASTION_IP }} \
              "aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}"
          scp -o StrictHostKeyChecking=no \
              -i bastion_key.pem \
              ${{ env.BASTION_USER }}@${{ env.BASTION_IP }}:~/.kube/config ./kubeconfig

      # 12. Fetch AWS Secrets & create K8s secret
      - name: Fetch AWS Secrets & Store in Kubernetes
        env:
          KUBECONFIG: ./kubeconfig
        run: |
          DB=$(aws secretsmanager get-secret-value --secret-id rtb-dev/db --query SecretString --output text)
          AW=$(aws secretsmanager get-secret-value --secret-id rtb-dev/auth-service --query SecretString --output text)
          if [ -z "$DB" ] || [ -z "$AW" ]; then
            echo "‚ùå Missing AWS secrets" && exit 1
          fi
          echo "$DB" | jq -r 'to_entries|.[]|"\(.key)=\(.value)"' > secrets.env
          echo "$AW" | jq -r 'to_entries|.[]|"\(.key)=\(.value)"' >> secrets.env
          PUB_B64=$(base64 -w0 public_key.pem)
          echo "PUBLIC_KEY_CONTENT=${PUB_B64}" >> secrets.env

          kubectl delete secret ${{ env.DEPLOYMENT_NAME }} -n ${{ env.K8S_NAMESPACE }} --ignore-not-found
          kubectl create secret generic ${{ env.DEPLOYMENT_NAME }} \
            --from-env-file=secrets.env \
            -n ${{ env.K8S_NAMESPACE }}

      # 13. Login to Amazon ECR
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      # 14. Build & push Docker image
      - name: Build & Push Docker Image
        run: |
          IMAGE_URI=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.DEPLOYMENT_NAME }}
          
          # Build with proper platform and entrypoint
          docker buildx create --use
          docker buildx build --platform linux/amd64 \
            -t ${IMAGE_URI}:${{ env.VERSION }} \
            -t ${IMAGE_URI}:latest \
            --push .
          
          # Save image URI for deployment
          echo "IMAGE_URI=${IMAGE_URI}" >> $GITHUB_ENV

      # 15. Deploy to EKS with rollout strategy
      - name: Deploy to EKS
        env:
          KUBECONFIG: ./kubeconfig
        run: |
          # Add rollout strategy to deployment if not exists
          kubectl patch deployment ${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.K8S_NAMESPACE }} \
            -p '{"spec":{"strategy":{"rollingUpdate":{"maxSurge":"25%","maxUnavailable":"25%"}}}}' \
            --type=merge || true
          
          # Perform deployment
          kubectl set image deployment/${{ env.DEPLOYMENT_NAME }} \
            ${{ env.DEPLOYMENT_NAME }}=$IMAGE_URI:${{ env.VERSION }} \
            -n ${{ env.K8S_NAMESPACE }}
          
          # Wait for rollout with timeout
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.K8S_NAMESPACE }} \
            --timeout=300s

      # 16. Notify Build Result
      - name: Notify Build Result
        if: always()
        continue-on-error: true
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            status="‚úÖ Build Success"
          else
            status="‚ùå Build Failure"
          fi
          
          payload='{
            "text": "'"$status"'\n*Repository:* '"$GITHUB_REPOSITORY"'\n*Run #:* '"$GITHUB_RUN_NUMBER"'\n*Commit:* '"${{ env.COMMIT_MESSAGE }}"'\n*By:* '"${{ env.COMMIT_AUTHOR }}"'\n*URL:* '"$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"'"
          }'
          
          curl -X POST -H "Content-Type: application/json" \
            --data "$payload" \
            "${{ secrets.GOOGLE_CHAT_WEBHOOK }}" || echo "Notification failed"
